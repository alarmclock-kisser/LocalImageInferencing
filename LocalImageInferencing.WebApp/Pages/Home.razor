@page "/"
@page "/home"

@using LocalImageInferencing.Shared
@using Microsoft.AspNetCore.Components.Web
@using LocalImageInferencing.Client
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components
@using Microsoft.JSInterop
@using System.Diagnostics
@using Radzen
@using Radzen.Blazor
@inject ApiClient ApiClient
@inject IJSRuntime JSRuntime
@inject LocalImageInferencing.WebApp.WebAppConfig AppCfg
@using LocalImageInferencing.WebApp.Pages

<!-- Markup angepasst: Alle Bindings und Zugriffe auf ViewModel -->
<RadzenCard Style="margin-bottom:1rem;">
    <RadzenStack Orientation="Orientation.Horizontal" Gap="1rem" Style="align-items:center; justify-content:space-between;">
        <span style="font-family: 'Arial Black'; font-size:1.6rem;">LocalImageInferencing API + WebApp</span>
        <div style="display:flex; align-items:center; gap:.5rem;">
            <span title="Hell">☀️</span>
            <RadzenSwitch @bind-Value="ViewModel.IsDarkMode" Change="@(async (bool v)=> await OnDarkModeChanged(v))" />
            <span title="Dunkel">🌙</span>
        </div>
    </RadzenStack>
</RadzenCard>

<!-- Main Image/Frame Panel + Controls -->
<RadzenCard Style="margin-bottom:1rem;">
    <RadzenStack Orientation="Orientation.Horizontal" Gap="1.5rem" Style="align-items:flex-start;">
        <!-- Frame Viewing Panel -->
        <div style="flex:1; min-width:320px;">
            <div id="imageContainer" @oncontextmenu="OnImageContextMenu" style="position:relative; width:100%; height:@ViewModel.ImageHeightPx; background:#222; display:flex; align-items:center; justify-content:center; border:1px solid #444; border-radius:4px; overflow:hidden;">
                @if (!string.IsNullOrEmpty(ViewModel.CurrentImageBase64))
                {
                    <img src="@ViewModel.CurrentImageBase64" style="max-width:100%; max-height:100%; object-fit:contain;" />
                }
                else
                {
                    <span style="color:#888;">Kein Bild ausgewählt</span>
                }
                <div id="resizeHandle" title="Größe ändern" style="position:absolute; right:4px; bottom:4px; width:16px; height:16px; background:#555; border:1px solid #999; cursor:nwse-resize; border-radius:3px; display:flex; align-items:center; justify-content:center; font-size:9px; color:#ccc; user-select:none;">↔</div>
            </div>
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.75rem" Style="margin-top:8px; flex-wrap:wrap; align-items:center;">
                <InputFile id="hiddenUpload" OnChange="OnFileChanged" accept="image/*" style="display:none;" />
                <RadzenButton Icon="upload" Text="Upload" ButtonStyle="ButtonStyle.Primary" Click="TriggerFileSelect" />
                <RadzenButton Text="Download" Icon="download" Disabled="@(ViewModel.SelectedImageId == Guid.Empty)" Click="OnDownloadClick" />
                <RadzenDropDown TValue="string" Data="@ViewModel.DownloadFormats" @bind-Value="ViewModel.SelectedFormat" Style="width:120px;" />
                <RadzenButton Text="Entfernen" ButtonStyle="ButtonStyle.Danger" Icon="delete" Disabled="@(ViewModel.SelectedImageId == Guid.Empty)" Click="OnRemoveClick" />
                <RadzenButton Text="Clear All" ButtonStyle="ButtonStyle.Danger" Icon="delete_sweep" Click="OnClearAllClick" />
                <RadzenButton Text="Base64 anzeigen" Icon="code" Disabled="@(ViewModel.SelectedImageId == Guid.Empty)" Click="OnShowBase64" />
            </RadzenStack>
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.75rem" Style="margin-top:8px; align-items:center;">
                <RadzenNumeric @bind-Value="ViewModel.CurrentFrame" Min="0" Max="@(ViewModel.CurrentImageInfo?.FramesCount > 0 ? ViewModel.CurrentImageInfo.FramesCount - 1 : 0)" Style="width:120px;" Change="@(async (int v) => await OnFrameChanged(v))" Placeholder="Frame" />
            </RadzenStack>
        </div>
        <!-- Image/Frame Meta Info Panel -->
        <div style="width:340px; min-width:220px;">
            <RadzenPanel AllowCollapse="true" Text="Bild/Frame Informationen" Collapsed="true">
                <ChildContent>
                    <RadzenStack Orientation="Orientation.Vertical" Gap="4px">
                        <RadzenLabel Text="Datei:" />
                        <RadzenLabel Text="@(ViewModel.CurrentImageInfo?.FilePath ?? "-")" Style="font-weight:bold" />
                        <RadzenLabel Text="GUID:" />
                        <RadzenLabel Text="@(ViewModel.CurrentImageInfo?.Id.ToString() ?? "-")" />
                        <RadzenLabel Text="Auflösung:" />
                        <RadzenLabel Text="@ViewModel.ImageResolutionText" />
                        <RadzenLabel Text="Datenmenge (aktuelles Frame):" />
                        <RadzenLabel Text="@ViewModel.ImageDataSizeKBText" />
                        <RadzenLabel Text="Anzahl Frames:" />
                        <RadzenLabel Text="@(ViewModel.CurrentImageInfo == null || ViewModel.CurrentImageInfo.Id == Guid.Empty ? "-" : ViewModel.CurrentImageInfo.FramesCount.ToString())" />
                    </RadzenStack>
                </ChildContent>
            </RadzenPanel>
        </div>
    </RadzenStack>
</RadzenCard>

<!-- Images List -->
<RadzenCard Style="margin-bottom:1rem;">
    <RadzenStack Orientation="Orientation.Vertical" Gap="8px">
        <RadzenLabel Text="Images List" Style="font-weight:bold; font-size:1.1rem;" />
        <RadzenListBox TValue="Guid" Data="@ViewModel.ImageListEntries" Value="@ViewModel.SelectedImageId" ValueChanged="@OnListSelectionChanged" TextProperty="DisplayText" ValueProperty="Id" Style="width:100%; height:180px;" />
    </RadzenStack>
</RadzenCard>

<!-- Prompt/LLM/Options Row -->
<RadzenStack Orientation="Orientation.Horizontal" Gap="1.5rem" Style="margin-bottom:1rem; align-items:flex-start;">
    <RadzenCard Style="flex:2;">
        <RadzenStack Orientation="Orientation.Vertical" Gap="8px">
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.75rem" Style="align-items:center; flex-wrap:wrap;">
                <RadzenCheckBox @bind-Value="ViewModel.UseThinking" />
                <RadzenLabel Text="Denken (DeepThinking)" />
                <RadzenCheckBox @bind-Value="ViewModel.UseAllFrames" />
                <RadzenLabel Text="Alle Frames" />
            </RadzenStack>
            <RadzenTextBox @bind-Value="ViewModel.PromptText" Placeholder="Prompt/Frage..." Style="width:100%;" @onkeydown="OnPromptTextBoxKeyDown" />
            <RadzenStack Orientation="Orientation.Horizontal" Gap="0.75rem" Style="align-items:center; flex-wrap:wrap;">
                <RadzenButton Text="Fragen (Text)" Icon="send" ButtonStyle="ButtonStyle.Primary" Click="OnPromptSend" />
                <RadzenButton Text="Fragen (Image)" Icon="image" ButtonStyle="ButtonStyle.Light" Click="OnPromptSendImage" />
                <RadzenButton Text="→ JSON aus Bild(en)" Icon="code" ButtonStyle="ButtonStyle.Light" Click="OnPromptFieldsToJson" />
                <RadzenLabel Style="font-size:12px; opacity:.85; margin-left:1rem;">
                    Response-Zeit: @ViewModel.LastResponseText
                </RadzenLabel>
            </RadzenStack>
            <RadzenTextArea @bind-Value="ViewModel.LlmResponse" ReadOnly="true" Style="width:100%; min-height:180px; font-family:monospace; resize:vertical;" />
        </RadzenStack>
    </RadzenCard>
</RadzenStack>




<!-- ViewModel für die Seite Home -->
@code {
    private HomeViewModel ViewModel = new();

    // Methoden für UI-Interaktion und Lifecycle bleiben hier
    protected override async Task OnInitializedAsync()
    {
        await LoadImageList();

        await base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                var theme = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", "theme");
                if (string.IsNullOrWhiteSpace(theme))
                {
                    ViewModel.IsDarkMode = AppCfg.DefaultDarkMode;
                }
                else
                {
                    ViewModel.IsDarkMode = string.Equals(theme, "dark", StringComparison.OrdinalIgnoreCase);
                }

                

                await ApplyTheme();
            }
            catch { }
        }
        if (firstRender && !ViewModel._resizeJsInitialized)
        {
            await JSRuntime.InvokeVoidAsync("initImageResizer", "imageContainer", "resizeHandle");
            ViewModel._resizeJsInitialized = true;
        }
    }

    private void BuildImageListEntries()
    {
        ViewModel.BuildImageListEntries();
    }

    private async Task LoadImageList()
    {
        ViewModel.ImageList = (await ApiClient.GetImageListAsync()).ToList();
        BuildImageListEntries();
        if (ViewModel.ImageList.Count == 0)
        {
            ViewModel.SelectedImageId = Guid.Empty;
            ViewModel.CurrentImageBase64 = string.Empty;
            ViewModel.ResetFrameMeta();
            StateHasChanged();
            return;
        }
        if (!ViewModel.ImageList.Any(i => i.Id == ViewModel.SelectedImageId))
        {
            ViewModel.SelectedImageId = ViewModel.ImageList[0].Id;
        }
        ViewModel.CurrentFrame = 0;
        await LoadCurrentImage();
    }

    private async Task LoadCurrentImage()
    {
        if (ViewModel.SelectedImageId == Guid.Empty)
        {
            ViewModel.CurrentImageBase64 = string.Empty;
            ViewModel.ResetFrameMeta();
            StateHasChanged();
            return;
        }
        var data = await ApiClient.GetImageData(ViewModel.SelectedImageId, ViewModel.CurrentFrame);
        if (!string.IsNullOrEmpty(data?.Base64Data))
        {
            ViewModel.CurrentImageBase64 = $"data:image/png;base64,{data.Base64Data}";
            ViewModel.GetType().GetField("_currentWidth", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.SetValue(ViewModel, data.Width);
            ViewModel.GetType().GetField("_currentHeight", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.SetValue(ViewModel, data.Height);
            ViewModel.GetType().GetField("_lastFrameBytes", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.SetValue(ViewModel, (data.Base64Data.Length * 3) / 4);
        }
        else
        {
            ViewModel.CurrentImageBase64 = string.Empty;
            ViewModel.ResetFrameMeta();
        }
        StateHasChanged();
    }

    private async Task OnListSelectionChanged(Guid value)
    {
        if (value == Guid.Empty) return;
        ViewModel.SelectedImageId = value;
        ViewModel.CurrentFrame = 0;
        await LoadCurrentImage();
        StateHasChanged();
    }

    private async Task OnFrameChanged(int value)
    {
        ViewModel.CurrentFrame = value;
        await LoadCurrentImage();
    }

    private async Task OnFileChanged(InputFileChangeEventArgs args)
    {
        IBrowserFile? file = null;
        try
        {
            if (args?.FileCount > 0)
            {
                var files = args.GetMultipleFiles(1);
                if (files != null && files.Count > 0)
                {
                    file = files[0];
                }
            }
        }
        catch
        {
            var files = args?.GetMultipleFiles();
            if (files != null && files.Count > 0)
            {
                file = files[0];
            }
        }
        if (file == null) return;
        var info = await ApiClient.UploadImageAsync(file);
        if (info != null && info.Id != Guid.Empty)
        {
            ViewModel.SelectedImageId = info.Id;
            var existing = ViewModel.ImageList.FirstOrDefault(x => x.Id == info.Id);
            if (existing == null)
            {
                ViewModel.ImageList.Insert(0, info);
            }
            else
            {
                existing.FilePath = info.FilePath;
            }
            BuildImageListEntries();
            await LoadCurrentImage();
            await LoadImageList();
        }
        else
        {
            await LoadImageList();
        }
    }

    private async Task OnRemoveClick()
    {
        if (ViewModel.SelectedImageId == Guid.Empty) return;
        await ApiClient.RemoveImageAsync(ViewModel.SelectedImageId);
        await LoadImageList();
    }

    private async Task OnDownloadClick()
    {
        if (ViewModel.SelectedImageId == Guid.Empty) return;

        var result = await ApiClient.DownloadImageAsync(ViewModel.SelectedImageId, ViewModel.CurrentFrame, ViewModel.SelectedFormat);
        if (result == null)
        {
            ViewModel.LlmResponse = "Download fehlgeschlagen oder keine Daten.";
            StateHasChanged();
            return;
        }

        var stream = result.Stream;
        if (stream == null)
        {
            ViewModel.LlmResponse = "Download fehlgeschlagen oder keine Daten.";
            StateHasChanged();
            return;
        }
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        var bytes = ms.ToArray();
        await JSRuntime.InvokeVoidAsync("downloadBlob", bytes);
    }

    private void OnImageContextMenu(MouseEventArgs e)
    {
        // Browser-Kontextmenü zulassen
    }

    public async Task OnShowBase64()
    {
        if (ViewModel.SelectedImageId == Guid.Empty)
        {
            ViewModel.LlmResponse = "Kein Bild ausgewählt.";
            return;
        }
        var data = await ApiClient.GetImageData(ViewModel.SelectedImageId, ViewModel.CurrentFrame);
        if (data != null && !string.IsNullOrEmpty(data.Base64Data))
        {
            ViewModel.LlmResponse = data.Base64Data;
        }
        else
        {
            ViewModel.LlmResponse = "Konnte Bilddaten nicht laden.";
        }
    }

    private async Task OnPromptSend()
    {
        ViewModel.LlmResponse = "Warte auf Antwort...";
        StateHasChanged();
        var response = await ApiClient.GenerateTextAsync(ViewModel.PromptText);
        ViewModel.LastResponseSeconds = response.ResponseDelaySeconds;
        ViewModel.LlmResponse = response.ResponseText;
        StateHasChanged();
    }

    private async Task OnPromptSendImage()
    {
        ViewModel.LlmResponse = "Warte auf Antwort...";
        StateHasChanged();

        int? frameId = ViewModel.UseAllFrames ? null : ViewModel.CurrentFrame;

        var response = await ApiClient.GenerateTextFromImageAsync(ViewModel.PromptText, ViewModel.SelectedImageId, frameId);
        ViewModel.LastResponseSeconds = response.ResponseDelaySeconds;
        ViewModel.LlmResponse = response.ResponseText;
        StateHasChanged();
    }

    private Task OnUseAllFramesChanged(bool v)
    {
        ViewModel.UseAllFrames = v;
        return Task.CompletedTask;
    }

    private async Task OnDarkModeChanged(bool v)
    {
        ViewModel.IsDarkMode = v;
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "theme", v ? "dark" : "light");
        await ApplyTheme();
    }

    private async Task ApplyTheme()
    {
        await JSRuntime.InvokeVoidAsync("setBodyTheme", ViewModel.IsDarkMode ? "theme-dark" : "theme-light");
        await JSRuntime.InvokeVoidAsync("setRadzenTheme", ViewModel.IsDarkMode ? "dark" : "default");
    }

    private async Task OnPromptFieldsToJson()
    {
        if (ViewModel.SelectedImageId == Guid.Empty)
        {
            ViewModel.LlmResponse = "Kein Bild ausgewählt.";
            return;
        }
        ViewModel.LlmResponse = "Warte auf Antwort...";
        StateHasChanged();
        int? frameId = ViewModel.UseAllFrames ? null : ViewModel.CurrentFrame;
        string prompt = "Du bist ein Nutzereingaben-Textfeld-Erkennungs-Experte in Scandaten (Bild/Bilder). " +
                        "Gib pixelgenaue Koordinaten als JSON-String mit kurzer Beschreibung (camelCase) & Confidence (0.0–1.0) aus, " +
                        "wo geschwärzt werden müsste, um ein Blanko-Formular zu erhalten." +
                        "Antwort-JSON soll in DTOs eingelesen werden: 'ImageResponseRectList' mit Guid imageId, int frameId und 'IEnumerable<ImageResponseRect> rectangles' " +
                        "(int x, int y, int width, int height, float confidence, string label).";
        var response = await ApiClient.GenerateTextFromImageAsync(prompt, ViewModel.SelectedImageId, frameId, "png");
        ViewModel.LastResponseSeconds = response.ResponseDelaySeconds;
        ViewModel.LlmResponse = ViewModel.CleanModelJson(response.ResponseText);
        var parsed = await TryParseResponseJson();
        if (parsed != null)
        {
            ViewModel.LlmResponse += "\n\n—\n\nErkannte Felder:\n";
            foreach (var r in parsed.Rectangles)
            {
                ViewModel.LlmResponse += $"- [{r.Confidence:P1}] {r.Label} @ ({r.X},{r.Y}) {r.Width}x{r.Height}\n";
            }
        }
        else
        {
            ViewModel.LlmResponse += "\n\n—\n\nKonnte JSON nicht parsen.";
        }
        StateHasChanged();
    }

    private async Task<HomeViewModel.ImageResponseRectList?> TryParseResponseJson()
    {
        if (string.IsNullOrWhiteSpace(ViewModel.LlmResponse))
            return null;
        try
        {
            var cleanedJson = ViewModel.CleanModelJson(ViewModel.LlmResponse);
            var result = System.Text.Json.JsonSerializer.Deserialize<HomeViewModel.ImageResponseRectList>(cleanedJson);
            return result;
        }
        catch
        {
            return null;
        }
        finally
        {
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task OnClearAllClick(MouseEventArgs args)
    {
        await ApiClient.ClearImagesAsync();
        await LoadImageList();
        StateHasChanged();
    }

    private async Task OnPromptTextBoxKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            if (e.ShiftKey)
                await OnPromptSendImage();
            else
                await OnPromptSend();
        }
    }

    private async Task TriggerFileSelect()
    {
        await JSRuntime.InvokeVoidAsync("triggerHiddenUpload", "hiddenUpload");
    }
}




<style>
.options-grid { display:grid; grid-template-columns: 220px 1fr; gap:6px 12px; align-items:center; }
</style>

<script>
    window.initImageResizer = (containerId, handleId) => {
        const el = document.getElementById(containerId);
        const handle = document.getElementById(handleId);
        if (!el || !handle) return;
        let startX = 0, startY = 0, startW = 0, startH = 0, resizing = false;
        const minW = 200, minH = 150;
        handle.addEventListener('mousedown', e => {
            e.preventDefault();
            startX = e.clientX;
            startY = e.clientY;
            const rect = el.getBoundingClientRect();
            startW = rect.width;
            startH = rect.height;
            resizing = true;
            document.body.style.userSelect = 'none';
        });
        window.addEventListener('mousemove', e => {
            if (!resizing) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            let newW = startW + dx;
            let newH = startH + dy;
            if (newW < minW) newW = minW;
            if (newH < minH) newH = minH;
            el.style.width = newW + 'px';
            el.style.height = newH + 'px';
        });
        window.addEventListener('mouseup', () => {
            if (resizing) {
                resizing = false;
                document.body.style.userSelect = '';
            }
        });
    };
    window.downloadImageFrame = async (url) => {
        try {
            const resp = await fetch(url);
            if (!resp.ok) {
                console.error('Download fehlgeschlagen', resp.status, resp.statusText);
                return;
            }
            const disposition = resp.headers.get('content-disposition');
            let fileName = 'image';
            if (disposition && disposition.indexOf('filename=') !== -1) {
                const match = /filename="?([^";]+)"?/i.exec(disposition);
                if (match && match[1]) {
                    fileName = match[1];
                }
            }
            const blob = await resp.blob();
            const blobUrl = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = blobUrl;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(blobUrl), 2000);
        } catch (e) {
            console.error('Download-Exception', e);
        }
    };
    window.setBodyTheme = (cls) => {
        document.body.classList.remove('theme-light','theme-dark');
        document.body.classList.add(cls);
    }
    // Download als Blob (falls noch nicht vorhanden)
    window.downloadBlob = (bytes, fileName, mimeType) => {
        try {
            const blob = new Blob([new Uint8Array(bytes)], { type: mimeType || 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName || 'download';
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(url), 1500);
        } catch (e) {
            console.error('downloadBlob error', e);
        }
    };
    window.triggerHiddenUpload = (id) => {
        const el = document.getElementById(id);
        if (el) el.click();
    }
</script>
